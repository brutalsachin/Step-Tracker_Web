<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Step Tracker with 3D Navigation</title>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            text-align: center;
            padding: 1em;
            margin: 0;
            overflow-x: hidden;
            background: #1a1a2e; /* Darker background */
            color: #e0e0e0; /* Lighter text color */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        h2 {
            color: #e0e0e0;
            margin-bottom: 20px;
        }
        
        /* AR View Styles */
        #ar-container {
            position: relative;
            width: 100%;
            max-width: 800px; /* Max width for larger screens */
            margin: 0 auto;
            height: 60vh;
            border-radius: 15px; /* Rounded corners */
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            background-color: #000; /* Fallback background */
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror camera feed */
            display: block;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to video */
            z-index: 10;
        }
        
        /* Map View Styles */
        #map-container {
            display: none; /* Hidden by default */
            position: relative;
            margin: 20px auto;
            width: 100%;
            max-width: 640px; /* Match canvas width */
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        #map {
            border: 1px solid #333;
            display: block;
            margin: 0 auto;
            background: #282844; /* Darker map background */
            border-radius: 10px;
        }
        
        #map-arrow {
            position: absolute;
            width: 30px;
            height: 30px;
            /* Using inline SVG for a crisp arrow */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%234CAF50" d="M12 2L4 12l8 10 8-10z"/></svg>');
            background-size: contain;
            pointer-events: none;
            transform-origin: center;
            transition: transform 0.1s ease-out; /* Smooth map arrow movement */
        }
        
        /* Control Styles */
        #controls {
            margin: 20px auto;
            padding: 20px;
            background: rgba(40, 40, 68, 0.8); /* Slightly transparent dark background */
            border-radius: 15px; /* Rounded corners */
            max-width: 500px;
            width: 90%; /* Responsive width */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; /* Spacing between buttons */
        }
        
        button {
            background: linear-gradient(145deg, #6a0572, #8a0572); /* Gradient button */
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0; /* Managed by gap in flexbox */
            border-radius: 25px; /* More rounded */
            font-size: 17px;
            cursor: pointer;
            transition: all 0.3s ease; /* Smooth transitions for hover/active */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 120px; /* Minimum width for buttons */
        }
        
        button:hover {
            background: linear-gradient(145deg, #8a0572, #6a0572);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .view-toggle {
            background: linear-gradient(145deg, #ff9800, #e68900); /* Orange gradient */
        }

        .view-toggle:hover {
            background: linear-gradient(145deg, #e68900, #ff9800);
        }
        
        #sensor-info {
            margin: 15px 0;
            font-size: 17px;
            background: rgba(60, 60, 90, 0.7); /* Slightly lighter background */
            padding: 12px;
            border-radius: 10px;
            width: 100%; /* Full width within controls */
            box-sizing: border-box; /* Include padding in width */
            line-height: 1.5;
            color: #c0c0c0;
            text-align: left; /* Align sensor data to left */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #ar-container {
                height: 50vh;
            }
            #controls {
                flex-direction: column; /* Stack buttons on small screens */
                padding: 15px;
            }
            button {
                width: 100%;
                min-width: unset;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <h2>AR Step Tracker with 3D Navigation</h2>
    
    <div id="ar-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="three-canvas"></canvas> 
    </div>
    
    <div id="map-container">
        <canvas id="map" width="640" height="480"></canvas>
        <div id="map-arrow"></div>
    </div>
    
    <div id="controls">
        <div id="sensor-info">Initializing sensors...</div>
        <button class="view-toggle" onclick="toggleView()">üó∫Ô∏è Show Map</button>
        <button onclick="resetTracker()">üîÑ Reset Position</button>
        <button onclick="setRandomTarget()">üéØ New Target</button>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById('video');
        const map = document.getElementById('map');
        const ctx = map.getContext('2d');
        const mapArrow = document.getElementById('map-arrow');
        const threeCanvas = document.getElementById('three-canvas');
        const sensorInfoDiv = document.getElementById('sensor-info');
        
        // Three.js Variables
        let scene, camera, renderer, arrowMesh;
        
        // Tracking Variables
        const scale = 10; // Scale for map grid
        const gridSize = 64; // Size of the virtual grid
        let targetPosition = { x: 20, y: 40 }; // Grid coordinates
        let currentPosition = { x: 0, y: 0 };
        let trail = [];
        let stepCount = 0;
        
        // Sensor Data (Current values)
        let heading = 0; // Alpha: Z-axis (compass heading)
        let pitch = 0;   // Beta: X-axis (front-back tilt)
        let roll = 0;    // Gamma: Y-axis (side-to-side tilt)
        let accX = 0, accY = 0, accZ = 0; // Acceleration including gravity
        let rotRateX = 0, rotRateY = 0, rotRateZ = 0; // Gyroscope rotational rates
        let magX = 0, magY = 0, magZ = 0; // Raw Magnetometer data
        let pressure = 0; // Barometer pressure data
        
        // Step Detection
        const stepLength = 1.0; // Meters per step (approximate)
        const stepThreshold = 1.5; // Acceleration magnitude threshold for a step (tuned for realism)
        const minStepInterval = 400; // Minimum time between steps in ms
        let lastStepTime = 0;
        let lastMagnitude = 0;
        const alphaFilter = 0.8; // Low-pass filter coefficient for acceleration
        
        // Initialize App
        function initApp() {
            console.log("initApp: Starting initialization.");
            // Start camera
            initCamera();
            
            // Initialize Three.js scene
            initThreeJs();
            
            // Start sensors
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleOrientation);
                console.log("DeviceOrientationEvent listener added (fused orientation).");
            } else {
                console.warn("DeviceOrientationEvent not supported.");
                sensorInfoDiv.textContent = "Orientation sensor (fused) not supported.";
            }
            
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleMotion);
                console.log("DeviceMotionEvent listener added (fused motion).");
            } else {
                console.warn("DeviceMotionEvent not supported.");
                sensorInfoDiv.textContent = "Motion sensor (fused) not supported.";
            }

            // Attempt to use Generic Sensor API for raw data (Magnetometer, Barometer)
            initGenericSensors();
            
            // Draw initial map
            drawMap();
            
            // Set initial random target
            setRandomTarget();
            console.log("initApp: Initialization complete.");
        }

        // Initialize Generic Sensors (Magnetometer, Barometer)
        function initGenericSensors() {
            // Magnetometer
            if ('Magnetometer' in window) {
                try {
                    const magnetometer = new Magnetometer({ frequency: 10 }); // 10 Hz updates
                    magnetometer.addEventListener('reading', () => {
                        magX = magnetometer.x;
                        magY = magnetometer.y;
                        magZ = magnetometer.z;
                        updateSensorInfo(); // Update display with raw data
                    });
                    magnetometer.addEventListener('error', event => {
                        if (event.error.name === 'NotAllowedError') {
                            console.warn('Permission to access raw Magnetometer was denied. Ensure HTTPS and grant permission.');
                            document.getElementById('raw-mag-status').textContent = "Permission denied or HTTPS required.";
                        } else {
                            console.error('Magnetometer error:', event.error);
                            document.getElementById('raw-mag-status').textContent = `Error: ${event.error.name}`;
                        }
                    });
                    magnetometer.start();
                    console.log("Raw Magnetometer sensor started.");
                    document.getElementById('raw-mag-status').textContent = "Active";
                } catch (error) {
                    console.error('Magnetometer API failed to start:', error);
                    document.getElementById('raw-mag-status').textContent = `API failed: ${error.name}`;
                }
            } else {
                console.warn("Raw Magnetometer API not supported by this browser.");
                document.getElementById('raw-mag-status').textContent = "Not supported";
            }

            // Barometer
            if ('Barometer' in window) {
                try {
                    const barometer = new Barometer({ frequency: 1 }); // 1 Hz updates
                    barometer.addEventListener('reading', () => {
                        pressure = barometer.pressure;
                        updateSensorInfo(); // Update display with raw data
                    });
                    barometer.addEventListener('error', event => {
                        if (event.error.name === 'NotAllowedError') {
                            console.warn('Permission to access Barometer was denied. Ensure HTTPS and grant permission.');
                            document.getElementById('raw-baro-status').textContent = "Permission denied or HTTPS required.";
                        } else {
                            console.error('Barometer error:', event.error);
                            document.getElementById('raw-baro-status').textContent = `Error: ${event.error.name}`;
                        }
                    });
                    barometer.start();
                    console.log("Raw Barometer sensor started.");
                    document.getElementById('raw-baro-status').textContent = "Active";
                } catch (error) {
                    console.error('Barometer API failed to start:', error);
                    document.getElementById('raw-baro-status').textContent = `API failed: ${error.name}`;
                }
            } else {
                console.warn("Raw Barometer API not supported by this browser.");
                document.getElementById('raw-baro-status').textContent = "Not supported";
            }
        }
        
        // Camera Initialization
        function initCamera() {
            sensorInfoDiv.textContent = "Requesting camera access...";
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment', // Prefer rear camera
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            }).then(stream => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    video.muted = true;
                    video.loop = true;
                    console.log("Camera stream started successfully.");
                    sensorInfoDiv.textContent = "Camera ready. Initializing sensors...";
                };
            }).catch(err => {
                console.error("Camera error:", err);
                sensorInfoDiv.textContent = `Camera access denied or failed: ${err.name}`;
            });
        }
        
        // Three.js Initialization
        function initThreeJs() {
            console.log("initThreeJs: Initializing Three.js.");
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            const arContainer = document.getElementById('ar-container');
            const initialWidth = arContainer.clientWidth;
            const initialHeight = arContainer.clientHeight;

            camera = new THREE.PerspectiveCamera(75, initialWidth / initialHeight, 0.1, 1000);
            camera.position.set(0, 0, 5); // Position camera slightly back
            camera.lookAt(0, 0, 0); // Look at the origin
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
            renderer.setSize(initialWidth, initialHeight); // Set initial size based on container
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0); // Transparent background
            
            // Lighting (for ambient glow and subtle highlights if material allows)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Soft white light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // Directional light for shadows/highlights
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Create the 3D Arrow Mesh with a custom shape
            const arrowShape = new THREE.Shape();
            
            // Define points for a sleek arrow shape (similar to the image)
            // Starting from bottom center, going clockwise
            arrowShape.moveTo(0, -1.0); // Bottom center
            arrowShape.lineTo(0.3, -1.0); // Bottom right corner
            arrowShape.lineTo(0.3, 0.5);  // Right side of shaft
            arrowShape.lineTo(0.8, 0.5);  // Right side of arrowhead base
            arrowShape.lineTo(0, 1.5);    // Top point of arrowhead
            arrowShape.lineTo(-0.8, 0.5); // Left side of arrowhead base
            arrowShape.lineTo(-0.3, 0.5); // Left side of shaft
            arrowShape.lineTo(-0.3, -1.0); // Bottom left corner
            arrowShape.lineTo(0, -1.0);   // Close the path
            
            // Extrude the shape to give it a slight thickness
            const extrudeSettings = {
                steps: 1,
                depth: 0.1, // Very thin, like a flat panel
                bevelEnabled: false // No bevel for a sharp, modern look
            };
            const arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
            
            // Center the geometry's pivot point
            arrowGeometry.center();

            // Create a material with emissive properties for the glowing effect
            const arrowMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000, // Base color (will be blended)
                emissive: 0xff0000, // Emissive color (makes it glow)
                emissiveIntensity: 1.0, // Increased glow intensity
                roughness: 0.3, // Less rough for a smoother look
                metalness: 0.1, // Slight metallic sheen
                transparent: true, // Enable transparency
                opacity: 0.9 // Slight transparency for a modern glass-like feel
            });
            
            arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);
            
            // Initial rotation for arrow to face the camera (along negative Z-axis)
            arrowMesh.rotation.x = -Math.PI / 2; // Makes the arrow point along positive Z
            arrowMesh.rotation.y = Math.PI; // Rotates it 180 degrees to point along negative Z (towards camera)
            
            // Initial scale and position to ensure visibility
            arrowMesh.scale.set(2.0, 2.0, 2.0); // Significantly larger initial scale
            arrowMesh.position.set(0, 0, -5); // Position it very close to the camera (camera is at Z=5, looking at 0,0,0)
            
            scene.add(arrowMesh);
            console.log("initThreeJs: Arrow mesh created and added to scene.");
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            // Call onWindowResize immediately to set correct aspect ratio and size
            onWindowResize(); 
            
            // Start the animation loop
            animate();
            console.log("initThreeJs: Three.js animation loop started.");
        }
        
        // Three.js Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Handle window resize for Three.js canvas
        function onWindowResize() {
            const arContainer = document.getElementById('ar-container');
            const width = arContainer.clientWidth;
            const height = arContainer.clientHeight;
            
            if (width === 0 || height === 0) {
                console.warn("AR container has zero dimensions on resize, skipping Three.js update.");
                return;
            }

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            console.log(`Three.js Renderer resized to: ${width}x${height}`);
        }
        
        // Sensor Handlers
        function handleOrientation(event) {
            heading = event.alpha || 0;
            pitch = event.beta || 0;
            roll = event.gamma || 0; // Capture roll (gamma)
            
            heading = (heading + 360) % 360;
            pitch = Math.max(-90, Math.min(90, pitch));
            roll = Math.max(-90, Math.min(90, roll)); // Clamp roll as well
            
            updateArArrow(arrowMesh, currentPosition, targetPosition, heading, pitch, roll); // Pass pitch and roll
            updateMapArrow();
            updateSensorInfo(); // Update info on orientation changes too
        }
        
        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity;
            const rotRate = event.rotationRate; // Get gyroscope data

            if (!acc || acc.x === null || acc.y === null || acc.z === null) {
                return;
            }
            // Store raw acceleration data
            accX = acc.x;
            accY = acc.y;
            accZ = acc.z;

            // Store raw gyroscope data
            if (rotRate) {
                // DeviceMotionEvent.rotationRate provides alpha, beta, gamma for rotational velocity
                // These typically correspond to Z, X, Y axes respectively.
                rotRateX = rotRate.alpha || 0; 
                rotRateY = rotRate.beta || 0;  
                rotRateZ = rotRate.gamma || 0; 
            } else {
                rotRateX = rotRateY = rotRateZ = 0; // Set to 0 if not available
            }
            
            const magnitude = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
            
            const filteredMagnitude = alphaFilter * lastMagnitude + (1 - alphaFilter) * magnitude;
            lastMagnitude = filteredMagnitude;
            
            const now = Date.now();
            if (filteredMagnitude > stepThreshold && (now - lastStepTime > minStepInterval)) {
                stepCount++;
                lastStepTime = now;
                
                const rad = (90 - heading) * Math.PI / 180;
                currentPosition.x += stepLength * Math.cos(rad);
                currentPosition.y += stepLength * Math.sin(rad);
                
                currentPosition.x = Math.max(0, Math.min(gridSize - 1, currentPosition.x));
                currentPosition.y = Math.max(0, Math.min(gridSize - 1, currentPosition.y));
                
                trail.push({ ...currentPosition });
                updateArArrow(arrowMesh, currentPosition, targetPosition, heading, pitch, roll); // Pass pitch and roll
                drawMap();
            }
            updateSensorInfo(); // Always update info on motion too, for raw data
        }
        
        // --- UPDATED updateArArrow FUNCTION ---
        function updateArArrow(arrowMesh, currentPosition, targetPosition, currentHeading, currentPitch, currentRoll) {
            if (!arrowMesh) {
                console.warn("Arrow mesh not initialized, cannot update AR arrow.");
                return;
            }
            
            // 1. Calculate direction vector from current to target
            const dx = targetPosition.x - currentPosition.x;
            const dy = targetPosition.y - currentPosition.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const targetAngleRad = Math.atan2(dx, dy); 
            const targetAngleDeg = (targetAngleRad * 180 / Math.PI + 360) % 360; 

            // 2. Calculate angle difference between target direction and user's heading
            let angleDiff = (targetAngleDeg - currentHeading + 360) % 360;
            if (angleDiff > 180) angleDiff -= 360; // Normalize to -180 to +180

            // 3. Set arrow rotation based on phone orientation
            // Y-axis rotation (Yaw): Horizontal turning towards target
            // Base rotation (Math.PI) makes arrow face camera (negative Z).
            // Then add angleDiff to turn left/right relative to camera's view.
            arrowMesh.rotation.y = Math.PI + (angleDiff * Math.PI / 180); 
            
            // X-axis rotation (Pitch): Vertical tilt of the phone
            // currentPitch is positive when tilting up. We want arrow to point down when looking up.
            // Initial arrow geometry points along positive Z (after -PI/2 X rotation).
            // So, positive pitch (looking up) means arrow should rotate negatively around its X-axis.
            const xRotation = -currentPitch * Math.PI / 180; 
            arrowMesh.rotation.x = xRotation - Math.PI / 2; // Combine with initial geometry rotation
            
            // Z-axis rotation (Roll): Side-to-side tilt of the phone
            // currentRoll is positive when tilting right. We want arrow to tilt right.
            // Three.js positive Z rotation is counter-clockwise. So, negative roll for clockwise tilt.
            arrowMesh.rotation.z = -currentRoll * Math.PI / 180; 

            // 4. Set arrow position (relative to camera, for example)
            // Dynamic Height (Y-axis): Arrow appears to move up/down in the view based on pitch
            // If looking up (positive pitch), arrow should appear lower (smaller Y).
            // If looking down (negative pitch), arrow should appear higher (larger Y).
            const baseArrowHeight = 1.5; // Default height above ground (in Three.js units)
            // Adjust Y position based on pitch. Max pitch +/-90 degrees.
            // Normalize pitch to -1 to 1 range, then scale it.
            const pitchAdjust = (currentPitch / 90) * 2; // Adjust factor for how much it moves vertically
            arrowMesh.position.y = baseArrowHeight - pitchAdjust;

            // Dynamic Depth (Z-axis): Arrow appears closer/further based on distance
            // Use a non-linear scaling for a more natural feel (e.g., quadratic easing)
            const normalizedDistance = Math.min(1, distance / 70); // Normalize distance over a larger range (e.g., up to 70m)
            const minArrowZ = -10; // Closest to camera (more negative means closer)
            const maxArrowZ = 5;  // Furthest from camera (more positive means further)
            // Quadratic easing: starts slow, accelerates
            const arrowZ = minArrowZ + (normalizedDistance * normalizedDistance) * (maxArrowZ - minArrowZ); 
            arrowMesh.position.z = arrowZ;
            
            // X-position (horizontal offset): Keep centered for now, but could be adjusted for target offset
            arrowMesh.position.x = 0; 
            
            // 5. Adjust scale based on distance
            // Arrow appears smaller when far, larger when close.
            const minScale = 0.2; // Minimum scale when very far
            const maxScale = 3.5; // Significantly increased maximum scale
            // Scale factor now uses normalizedDistance for smoother transition
            const scaleFactor = minScale + (1 - normalizedDistance) * (maxScale - minScale);
            arrowMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            
            // Update arrow color and emissive properties based on proximity to target
            const targetColor = new THREE.Color(0x00ff00); // Green when close
            const initialColor = new THREE.Color(0xff0000); // Red when far
            
            if (distance < 5) {
                const blendFactor = 1 - (distance / 5);
                arrowMesh.material.color.lerpColors(initialColor, targetColor, blendFactor);
                arrowMesh.material.emissive.lerpColors(initialColor, targetColor, blendFactor);
                arrowMesh.material.emissiveIntensity = 1.0 + (1 - blendFactor) * 1.0; // More intense glow when very close
            } else {
                arrowMesh.material.color.copy(initialColor);
                arrowMesh.material.emissive.copy(initialColor);
                arrowMesh.material.emissiveIntensity = 1.0;
            }
            
            updateSensorInfo();
        }
        // --- END UPDATED updateArArrow FUNCTION ---
        
        // Map Drawing Functions
        function drawMap() {
            if (map.style.display !== 'block') return;
            
            ctx.clearRect(0, 0, map.width, map.height);
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * scale, 0);
                ctx.lineTo(i * scale, map.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * scale);
                ctx.lineTo(map.width, i * scale);
                ctx.stroke();
            }
            
            ctx.fillStyle = 'rgba(0, 150, 255, 0.5)';
            trail.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x * scale + scale/2, pos.y * scale + scale/2, scale/3, 0, Math.PI*2);
                ctx.fill();
            });
            
            ctx.fillStyle = '#FF5722';
            ctx.fillRect(targetPosition.x * scale, targetPosition.y * scale, scale, scale);
            
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(
                currentPosition.x * scale + scale/2, 
                currentPosition.y * scale + scale/2, 
                scale/2, 0, Math.PI*2
            );
            ctx.fill();
            
            updateMapArrow();
        }
        
        function updateMapArrow() {
            if (map.style.display !== 'block') return;
            
            const dx = targetPosition.x - currentPosition.x;
            const dy = targetPosition.y - currentPosition.y;
            const targetAngle = Math.atan2(dx, dy) * (180 / Math.PI);
            
            const canvasRect = map.getBoundingClientRect();
            const arrowSize = 30;
            const arrowX = canvasRect.left + (currentPosition.x * scale + scale/2) - (arrowSize / 2);
            const arrowY = canvasRect.top + (currentPosition.y * scale + scale/2) - (arrowSize / 2);
            
            mapArrow.style.left = `${arrowX}px`;
            mapArrow.style.top = `${arrowY}px`;
            mapArrow.style.transform = `rotate(${targetAngle}deg)`;
        }
        
        // Info Display
        function updateSensorInfo() {
            const dx = targetPosition.x - currentPosition.x;
            const dy = targetPosition.y - currentPosition.y;
            const distance = Math.sqrt(dx**2 + dy**2).toFixed(1);
            
            const targetAngleDeg = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
            let angleDiff = (targetAngleDeg - heading + 360) % 360;
            if (angleDiff > 180) angleDiff -= 360;
            
            let turnDirection = angleDiff > 0 ? 'Right' : 'Left';
            if (Math.abs(angleDiff) < 5) turnDirection = 'Straight';
            
            sensorInfoDiv.innerHTML = `
                Steps: ${stepCount} | Distance: ${distance}m<br>
                Heading: ${heading.toFixed(0)}¬∞ | Turn: ${turnDirection} ${Math.abs(angleDiff).toFixed(0)}¬∞<br>
                Pitch: ${pitch.toFixed(0)}¬∞ | Roll: ${roll.toFixed(0)}¬∞<br>
                <hr style="border-color: #444; margin: 8px 0;">
                <span style="color: #a0d9f0;">-- Raw Sensor Data --</span><br>
                Acc (Incl. Gravity):<br>
                &nbsp;&nbsp;X: ${accX.toFixed(2)}m/s¬≤<br>
                &nbsp;&nbsp;Y: ${accY.toFixed(2)}m/s¬≤<br>
                &nbsp;&nbsp;Z: ${accZ.toFixed(2)}m/s¬≤<br>
                Gyro (Rot. Rate):<br>
                &nbsp;&nbsp;X: ${rotRateX.toFixed(2)}¬∞/s<br>
                &nbsp;&nbsp;Y: ${rotRateY.toFixed(2)}¬∞/s<br>
                &nbsp;&nbsp;Z: ${rotRateZ.toFixed(2)}¬∞/s<br>
                Magnetometer (Raw):<br>
                &nbsp;&nbsp;X: ${magX.toFixed(2)}ŒºT<br>
                &nbsp;&nbsp;Y: ${magY.toFixed(2)}ŒºT<br>
                &nbsp;&nbsp;Z: ${magZ.toFixed(2)}ŒºT<br>
                &nbsp;&nbsp;Status: <span id="raw-mag-status">Initializing...</span><br>
                Barometer (Raw):<br>
                &nbsp;&nbsp;Pressure: ${pressure.toFixed(2)}hPa<br>
                &nbsp;&nbsp;Status: <span id="raw-baro-status">Initializing...</span><br>
                <span style="font-size: 0.9em; color: #888;">(Raw sensor access requires HTTPS and user permission)</span>
            `;
        }
        
        // Control Functions
        function toggleView() {
            const mapContainer = document.getElementById('map-container');
            const arContainer = document.getElementById('ar-container');
            const toggleBtn = document.querySelector('.view-toggle');
            
            if (mapContainer.style.display === 'none' || !mapContainer.style.display) {
                mapContainer.style.display = 'block';
                arContainer.style.display = 'none';
                toggleBtn.textContent = 'üëÅÔ∏è Show AR';
                drawMap();
            } else {
                mapContainer.style.display = 'none';
                arContainer.style.display = 'block';
                toggleBtn.textContent = 'üó∫Ô∏è Show Map';
            }
        }
        
        function resetTracker() {
            currentPosition = { x: 0, y: 0 };
            trail = [];
            stepCount = 0;
            updateArArrow(arrowMesh, currentPosition, targetPosition, heading, pitch, roll); 
            drawMap();
            updateSensorInfo();
        }
        
        function setRandomTarget() {
            targetPosition = {
                x: Math.floor(Math.random() * gridSize),
                y: Math.floor(Math.random() * gridSize)
            };
            updateArArrow(arrowMesh, currentPosition, targetPosition, heading, pitch, roll); 
            drawMap();
            updateSensorInfo();
        }
        
        // Initialize on window load
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
