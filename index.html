<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step Tracker App</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #controls {
            margin: 10px;
            text-align: center;
        }

        canvas {
            border: 1px solid #ccc;
            margin-bottom: 20px;
        }

        @media (min-width: 600px) {
            #container { 
                flex-direction: row; 
            }
        }

        @keyframes celebrate {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); }
            100% { transform: scale(1); }
        }

        #userDot.goal {
            animation: celebrate 1s ease-in-out infinite;
            box-shadow: 0 0 8px gold;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <label for="age">Enter your age: </label>
            <input type="number" id="age" min="1" max="120" required><br><br>
            <label for="startX">Start (X): </label>
            <input type="number" id="startX" min="0" max="9">
            <label for="startY">Start (Y): </label>
            <input type="number" id="startY" min="0" max="9"><br><br>
            <label for="destX">Destination (X): </label>
            <input type="number" id="destX" min="0" max="9">
            <label for="destY">Destination (Y): </label>
            <input type="number" id="destY" min="0" max="9"><br><br>
            <button id="setDest">Set Destination</button>
            <button id="resetPath">Reset Path</button>
            <button id="redefineDest">Redefine Destination</button>
        </div>

        <canvas id="gridCanvas" width="640" height="640"></canvas>
    </div>

    <script>
        let age = parseInt(prompt("Enter your age:"));
        let strideLength;

        if (age < 40) strideLength = 0.75;
        else if (age < 60) strideLength = 0.65;
        else strideLength = 0.55;

        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 64;
        const cols = 10, rows = 10;

        let currentCol = 0, currentRow = 0;
        let destCol = 5, destRow = 5;
        let path = JSON.parse(localStorage.getItem('path')) || []; // Load saved path from localStorage
        let model;
        let isStepDetected = false;

        let stepData = [];
        let labels = [];
        let windowSize = 5;

        // Train a simple model
        async function trainModel() {
            model = tf.sequential();
            model.add(tf.layers.dense({units: 32, activation: 'relu', inputShape: [windowSize * 3]}));
            model.add(tf.layers.dense({units: 16, activation: 'relu'}));
            model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
            model.compile({optimizer: 'adam', loss: 'binaryCrossentropy'});

            await model.fit(tf.tensor2d(stepData), tf.tensor2d(labels, [labels.length, 1]), {
                epochs: 10,
                batchSize: 32
            });
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;

            for (let i = 0; i <= cols; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, rows * cellSize);
                ctx.stroke();
            }

            for (let j = 0; j <= rows; j++) {
                ctx.beginPath();
                ctx.moveTo(0, j * cellSize);
                ctx.lineTo(cols * cellSize, j * cellSize);
                ctx.stroke();
            }
        }

        function drawUser() {
            const x = currentCol * cellSize + cellSize / 2;
            const y = currentRow * cellSize + cellSize / 2;
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        function drawTarget() {
            const x = destCol * cellSize + cellSize / 2;
            const y = destRow * cellSize + cellSize / 2;
            ctx.fillStyle = 'green';
            ctx.fillRect(x - 15, y - 15, 30, 30);
        }

        function drawArrow() {
            const angle = Math.atan2(destRow - currentRow, destCol - currentCol);
            ctx.save();
            const x = currentCol * cellSize + cellSize / 2;
            const y = currentRow * cellSize + cellSize / 2;
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, -10); ctx.lineTo(0, 10);
            ctx.lineTo(20, 0);
            ctx.closePath();
            ctx.fillStyle = 'yellow';
            ctx.fill();
            ctx.restore();
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawTarget();
            drawUser();
            drawArrow();
        }

        function handleMotion(event) {
            let ax = event.acceleration.x;
            let ay = event.acceleration.y;
            let az = event.acceleration.z;

            stepData.push([ax, ay, az]);
            if (stepData.length > windowSize) {
                stepData.shift();
            }

            if (stepData.length === windowSize) {
                let input = tf.tensor2d([stepData.flat()]);
                model.predict(input).array().then(predictions => {
                    if (predictions[0] > 0.5) {
                        isStepDetected = true;
                    }

                    if (isStepDetected) {
                        moveUserOneCell();
                        isStepDetected = false;
                    }
                });
            }
        }

        function moveUserOneCell() {
            if (currentCol < destCol) currentCol++;
            else if (currentCol > destCol) currentCol--;

            if (currentRow < destRow) currentRow++;
            else if (currentRow > destRow) currentRow--;

            path.push({x: currentCol, y: currentRow});
            localStorage.setItem('path', JSON.stringify(path));  // Save path to localStorage
            update();
            if (currentCol === destCol && currentRow === destRow) {
                document.querySelector('#userDot').classList.add('goal');
            }
        }

        function setDestination() {
            destCol = parseInt(document.getElementById('destX').value);
            destRow = parseInt(document.getElementById('destY').value);
            currentCol = parseInt(document.getElementById('startX').value);
            currentRow = parseInt(document.getElementById('startY').value);
            path = [];
            update();
        }

        function resetPath() {
            path = [];
            localStorage.setItem('path', JSON.stringify(path));  // Clear path from localStorage
            update();
        }

        document.getElementById('setDest').addEventListener('click', setDestination);
        document.getElementById('resetPath').addEventListener('click', resetPath);

        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', handleMotion);
        }

        trainModel(); // Train the model after gathering some data

        update();
    </script>
</body>
</html>
